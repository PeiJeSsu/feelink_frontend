# GitHub Copilot 指導原則

## 基本溝通規範

### 語言與用詞
- **一律使用繁體中文回應**,採用台灣慣用的專業術語和表達方式
- **禁止使用表情符號**(emoji)、顏文字或任何圖示符號
- 使用台灣常用的技術用語,例如:
  - 使用「函式」而非「函数」或「方法」
  - 使用「變數」而非「变量」
  - 使用「陣列」而非「数组」
  - 使用「物件」而非「对象」
  - 使用「套件」而非「包」
  - 使用「元件」而非「组件」
  - 使用「程式碼」而非「代码」

### 回應風格
- 保持**簡潔、專業、直接**的溝通方式
- 避免過度客套或冗長的開場白
- 先提供解決方案,再說明理由
- 使用條列式呈現複雜資訊
- 不使用口語化或過於隨性的表達

## 專案特定規範

### 技術棧理解
本專案為 **Feelink 繪圖協作平台**,使用以下技術:
- **前端框架**: React 19 + React Router
- **UI 框架**: Material-UI (MUI)
- **畫布渲染**: Fabric.js (@erase2d/fabric)
- **狀態管理**: React Context API
- **後端服務**: Firebase (Authentication, Firestore, Storage)
- **國際化**: i18next + react-i18next
- **測試框架**: Jest + React Testing Library
- **程式碼品質**: SonarCloud

### 程式碼撰寫原則

#### 命名規範
- **元件檔案**: 使用 PascalCase,例如 `TopToolbar.jsx`
- **工具函式檔案**: 使用 PascalCase + 功能描述,例如 `BrushUtils.js`
- **樣式檔案**: 使用 camelCase,例如 `authStyles.js`
- **測試檔案**: 使用 `*.test.js` 或 `*.test.jsx`
- **變數與函式**: 使用 camelCase,例如 `handleSaveFile`
- **常數**: 使用 UPPER_SNAKE_CASE,例如 `MAX_CANVAS_SIZE`
- **元件 Props**: 使用 camelCase,並明確定義 PropTypes

#### 檔案組織
- 元件相關邏輯拆分為:
  - `components/`: React 元件
  - `helpers/`: 純函式工具
  - `hooks/`: 自訂 React Hooks
  - `contexts/`: React Context 定義
  - `styles/`: 樣式定義
  - `config/`: 設定檔
  - `utils/`: 通用工具函式
- 每個功能模組應包含對應的 `__tests__` 測試目錄

#### 程式碼風格
- 使用函式元件與 Hooks，避免使用 Class 元件
- 使用箭頭函式定義元件
- 使用解構賦值處理 props 和 state
- 優先使用 `const`，必要時才使用 `let`，避免使用 `var`
- 使用 ES6+ 語法
- 使用具名匯出(named export)而非預設匯出(除非元件為頁面主元件)

#### React 最佳實踐
- 元件內 Hooks 呼叫順序保持一致
- 使用 `useCallback` 優化事件處理函式
- 使用 `useMemo` 優化昂貴的計算
- 使用 `useEffect` 的清理函式避免記憶體洩漏
- 適當使用 PropTypes 進行型別檢查
- 避免在 JSX 中定義匿名函式

#### 測試要求
- 每個元件和工具函式都應有對應測試
- 測試覆蓋率目標: 80% 以上
- 使用描述性的測試案例名稱
- 測試應涵蓋:正常流程、邊界條件、錯誤處理
- 使用 `@testing-library/react` 進行元件測試
- Mock 外部依賴(Firebase, API 呼叫)

### 程式碼審查規範

#### 審查前準備
- **先理解專案整體架構**，再進行細節審查
- 確認修改範圍與相關聯的檔案
- 檢查是否符合專案現有的設計模式

#### 審查重點
1. **功能正確性**: 程式碼是否實現預期功能
2. **程式碼品質**: 可讀性、可維護性、可擴展性
3. **效能考量**: 是否有不必要的重複渲染或計算
4. **安全性**: 輸入驗證、XSS 防護、敏感資料處理
5. **錯誤處理**: 是否有適當的錯誤捕捉與使用者提示
6. **測試完整性**: 是否包含足夠的測試案例
7. **文件說明**: 複雜邏輯是否有註解說明
8. **相依性管理**: 是否引入不必要的套件

### 問題解決流程

#### 收到問題時
1. **釐清問題範圍**: 確認問題發生的檔案、元件、功能模組
2. **收集相關資訊**: 檢視相關程式碼、錯誤訊息、執行環境
3. **分析根本原因**: 不僅修正表面問題,更要找出根源
4. **提出解決方案**: 提供具體的程式碼修正
5. **說明修正理由**: 解釋為何這樣修改
6. **建議後續改善**: 如何避免類似問題再次發生

#### 提供解決方案時
- 直接提供可執行的程式碼
- 說明修改的檔案路徑
- 解釋修改的原因與影響範圍
- 提醒需要同步修改的相關檔案
- 建議執行測試驗證修正結果

### 新功能開發規範

#### 開發前
- 確認功能需求與設計規格
- 評估對現有架構的影響
- 規劃檔案結構與元件拆分
- 識別需要的共用工具與 Hooks

#### 開發中
- 遵循專案現有的程式碼風格
- 撰寫自我說明的程式碼(self-documenting code)
- 對複雜邏輯添加註解
- 確保與現有功能的整合性

#### 開發後
- 撰寫對應的測試案例
- 更新相關文件
- 進行自我程式碼審查
- 確認無 console 警告或錯誤

## 禁止事項

- ❌ 不使用任何表情符號或顏文字
- ❌ 不提供未經測試的程式碼
- ❌ 不忽略錯誤處理
- ❌ 不使用已廢棄的 API 或套件
- ❌ 不直接修改 node_modules
- ❌ 不提交包含敏感資訊的程式碼(API keys, passwords)
- ❌ 不使用簡體中文或中國大陸用語
- ❌ 不提供模糊或不完整的解決方案

## 特殊注意事項

### Firebase 使用
- 所有 Firebase 操作應包含錯誤處理
- 使用 Firebase 時注意資料安全規則
- 避免在前端暴露敏感設定

### Fabric.js 畫布操作
- 注意畫布物件的序列化與反序列化
- 處理大量物件時注意效能優化
- 確保畫布操作的 undo/redo 功能正常

### 國際化
- 所有使用者介面文字應使用 i18next
- 不在程式碼中寫死任何顯示文字
- 新增文字時同步更新語系檔案

### 效能優化
- 避免不必要的元件重新渲染
- 大型列表使用虛擬化技術
- 圖片上傳前進行壓縮處理
- 適當使用 lazy loading

## 總結

在協助開發 Feelink 專案時,請始終保持:
- **專業性**: 使用正式、準確的技術用語
- **完整性**: 提供可直接使用的完整解決方案
- **一致性**: 遵循專案既有的規範與風格
- **品質意識**: 注重程式碼品質、測試與文件
- **繁體中文**: 所有回應均使用台灣慣用的繁體中文
